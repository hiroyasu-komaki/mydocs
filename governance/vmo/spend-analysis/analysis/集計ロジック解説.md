# data_analyzer.py 集計ロジック解説

## 出力ファイル一覧

| No. | ファイル名 | 分析内容 | 対応メソッド |
|-----|-----------|---------|-------------|
| 1 | vendor_spend_analysis.csv | ベンダー別支出分析 | `analyze_vendor_spend()` |
| 2 | category_spend_analysis.csv | サービスカテゴリ別支出分析 | `analyze_category_spend()` |
| 3 | contract_type_spend_analysis.csv | 契約形態別支出分析 | `analyze_contract_type_spend()` |
| 4 | pareto_analysis.csv | パレート分析（データ詳細） | `analyze_pareto()` |
| 5 | pareto_summary.csv | パレート分析（サマリー） | `analyze_pareto()` |
| 6 | unit_price_analysis.csv | 契約単価ばらつき分析（統計） | `analyze_unit_price_variance()` |
| 7 | unit_price_details.csv | 契約単価ばらつき分析（詳細） | `analyze_unit_price_variance()` |
| 8 | auto_renewal_analysis.csv | 自動更新契約分析 | `analyze_auto_renewal()` |

---

<br>

## 1. vendor_spend_analysis.csv

### 目的
**ベンダーごとの年間支出額を集計し、支出の多い順にランキング化**

### 集計ロジック

#### データソース
- **contracts.csv**: 契約データ

#### フィルタリング条件
```python
contract_status == '有効'  # 有効な契約のみを対象
```

#### 集計処理（vendor_idでグループ化）
```python
vendor_spend = active_contracts.groupby('vendor_id').agg({
    'vendor_name': 'first',          # ベンダー名（最初の1件）
    'annual_amount': 'sum',          # 年間金額の合計
    'contract_id': 'count'           # 契約件数
})
```

#### 追加計算
1. **構成比の計算**
   ```python
   spend_ratio = (total_annual_spend / 総支出額) × 100
   ```

2. **累積構成比の計算**
   ```python
   # 支出額降順にソート後、累積和を計算
   cumulative_ratio = spend_ratio.cumsum()
   ```

3. **ベンダー情報の結合**
   - vendors.csvから以下の情報を結合:
     - `vendor_classification` (ベンダー分類)
     - `industry` (業種)
     - `vendor_rating` (評価スコア)

4. **ランク付け**
   - 支出額降順で1位から順位を付与

### 出力列

| 列名 | 説明 | 計算方法 |
|------|------|---------|
| rank | 順位 | 支出額降順 |
| vendor_id | ベンダーID | - |
| vendor_name | ベンダー名 | - |
| vendor_classification | ベンダー分類 | vendorsから結合 |
| industry | 業種 | vendorsから結合 |
| vendor_rating | 評価スコア | vendorsから結合 |
| total_annual_spend | 年間支出総額 | annual_amountの合計 |
| contract_count | 契約件数 | 契約IDのカウント |
| spend_ratio | 構成比(%) | (支出額/総支出額)×100 |
| cumulative_ratio | 累積構成比(%) | 構成比の累積和 |

### 用途
- どのベンダーに最も支出しているか把握
- 上位ベンダーへの集中度を確認
- ベンダーの分類・業種・評価と支出の関係を分析

---

<br>

## 2. category_spend_analysis.csv

### 目的
**サービスカテゴリ別の支出額を集計し、どの分野に多く支出しているか分析**

### 集計ロジック

#### データソース
- **orders.csv**: 発注データ

#### フィルタリング条件
```python
order_status == '支払済'  # 支払済の発注のみを対象
```

#### 集計処理（service_categoryでグループ化）
```python
category_spend = paid_orders.groupby('service_category').agg({
    'order_amount': 'sum',       # 発注金額の合計
    'order_id': 'count'          # 発注件数
})
```

#### 追加計算
1. **構成比の計算**
   ```python
   spend_ratio = (total_spend / 総支出額) × 100
   ```

2. **平均発注額の計算**
   ```python
   avg_order_amount = total_spend / order_count
   ```

3. **ランク付け**
   - 支出額降順で順位を付与

### 出力列

| 列名 | 説明 | 計算方法 |
|------|------|---------|
| rank | 順位 | 支出額降順 |
| service_category | サービスカテゴリ | - |
| total_spend | 総支出額 | order_amountの合計 |
| order_count | 発注件数 | order_idのカウント |
| avg_order_amount | 平均発注額 | total_spend / order_count |
| spend_ratio | 構成比(%) | (支出額/総支出額)×100 |

### 用途
- どのサービス分野に予算を投入しているか把握
- ITシステム開発、保守・運用、コンサルティング等の支出バランスを確認
- 平均発注額から、発注規模の傾向を分析

---

<br>

## 3. contract_type_spend_analysis.csv

### 目的
**契約形態別（固定金額、準委任など）の支出額を集計し、契約タイプの傾向を分析**

### 集計ロジック

#### データソース
- **contracts.csv**: 契約データ

#### フィルタリング条件
```python
contract_status == '有効'  # 有効な契約のみを対象
```

#### 集計処理（contract_typeでグループ化）
```python
contract_type_spend = active_contracts.groupby('contract_type').agg({
    'annual_amount': 'sum',      # 年間金額の合計
    'contract_id': 'count',      # 契約件数
    'monthly_amount': 'mean'     # 月額金額の平均
})
```

#### 追加計算
1. **構成比の計算**
   ```python
   spend_ratio = (total_annual_spend / 総支出額) × 100
   ```

2. **ランク付け**
   - 支出額降順で順位を付与

### 出力列

| 列名 | 説明 | 計算方法 |
|------|------|---------|
| rank | 順位 | 支出額降順 |
| contract_type | 契約形態 | - |
| total_annual_spend | 年間支出総額 | annual_amountの合計 |
| contract_count | 契約件数 | contract_idのカウント |
| avg_monthly_amount | 平均月額 | monthly_amountの平均 |
| spend_ratio | 構成比(%) | (支出額/総支出額)×100 |

### 用途
- 固定金額契約と準委任契約のバランスを確認
- 契約形態ごとの平均月額を比較
- コスト構造の最適化検討

---

<br>

## 4. pareto_analysis.csv

### 目的
**パレートの法則（80:20の法則）を検証 - 支出の80%を占めるベンダーを特定**

### 集計ロジック

#### 処理フロー
1. `analyze_vendor_spend()`を呼び出してベンダー別支出データを取得
2. 支出額降順にソート
3. 累積構成比を計算
4. 全ベンダーのデータを出力

#### データ内容
- 基本的に`vendor_spend_analysis.csv`と同じデータ
- パレート図作成のための元データとして使用

### 出力列
vendor_spend_analysis.csvと同一

### 用途
- パレート図（累積構成比グラフ）の作成
- 80%の支出を占める上位ベンダーの特定
- ベンダー集約の検討材料

---

<br>

## 5. pareto_summary.csv

### 目的
**パレート分析のサマリー情報 - 80%法則の検証結果を1行で出力**

### 集計ロジック

#### 計算処理
```python
# 累積構成比が80%以下のベンダーを抽出
vendors_80 = vendor_spend[vendor_spend['cumulative_ratio'] <= 80]

# サマリー情報を計算
summary = {
    'total_vendors': 全ベンダー数,
    'vendors_for_80_percent': 80%を占めるベンダー数,
    'vendor_ratio': (80%ベンダー数 / 全ベンダー数) × 100,
    'spend_80_amount': 80%ベンダーの支出額合計,
    'total_spend': 全体の支出額,
    'spend_80_ratio': (80%支出額 / 全支出額) × 100
}
```

### 出力列

| 列名 | 説明 | 計算方法 |
|------|------|---------|
| total_vendors | 全ベンダー数 | ベンダー総数 |
| vendors_for_80_percent | 80%を占めるベンダー数 | cumulative_ratio≤80のベンダー数 |
| vendor_ratio | ベンダー比率(%) | (80%ベンダー数/全ベンダー数)×100 |
| spend_80_amount | 80%分の支出額 | 上位ベンダーの支出額合計 |
| total_spend | 総支出額 | 全体の支出額 |
| spend_80_ratio | 支出比率(%) | 実際の構成比（80%前後） |

### 用途
- パレートの法則が成り立っているか確認
- 例：「全体の20%のベンダーで支出の80%を占める」かを検証
- ベンダー集約の目標設定

---

<br>

## 6. unit_price_analysis.csv

### 目的
**サービスカテゴリ別の契約単価のばらつきを統計分析**

### 集計ロジック

#### データソース
- **contracts.csv**: 契約データ（monthly_amount > 0）
- **orders.csv**: 発注データ（カテゴリ情報取得のため）

#### フィルタリング条件
```python
contract_status == '有効'  # 有効な契約
monthly_amount > 0         # 月額単価が存在する契約
contract_count >= 2        # 2件以上の契約があるカテゴリのみ
```

#### カテゴリの特定
```python
# 各契約の主要カテゴリを特定（ordersから最頻値を取得）
order_categories = orders.groupby('contract_id')['service_category'].agg(
    lambda x: x.mode()[0] if len(x.mode()) > 0 else x.iloc[0]
)
```

#### 統計計算（primary_categoryでグループ化）
```python
category_stats = contracts_with_price.groupby('primary_category')['monthly_amount'].agg([
    ('contract_count', 'count'),     # 契約数
    ('avg_price', 'mean'),           # 平均値
    ('median_price', 'median'),      # 中央値
    ('min_price', 'min'),            # 最小値
    ('max_price', 'max'),            # 最大値
    ('std_price', 'std')             # 標準偏差
])
```

#### 追加指標の計算
1. **変動係数（CV: Coefficient of Variation）**
   ```python
   cv = (std_price / avg_price) × 100
   ```
   - ばらつきの程度を示す指標
   - CV > 30% は「ばらつきが大きい」と判定

2. **価格レンジ**
   ```python
   price_range = max_price - min_price
   ```

3. **レンジ比率**
   ```python
   range_ratio = (price_range / avg_price) × 100
   ```

### 出力列

| 列名 | 説明 | 計算方法 |
|------|------|---------|
| rank | 順位 | CV値降順 |
| primary_category | サービスカテゴリ | - |
| contract_count | 契約数 | カウント |
| avg_price | 平均単価 | 平均値 |
| median_price | 中央値単価 | 中央値 |
| min_price | 最小単価 | 最小値 |
| max_price | 最大単価 | 最大値 |
| std_price | 標準偏差 | 標準偏差 |
| cv | 変動係数(%) | (標準偏差/平均)×100 |
| price_range | 価格レンジ | 最大-最小 |
| range_ratio | レンジ比率(%) | (レンジ/平均)×100 |

### 用途
- 同じカテゴリ内で単価にばらつきがないか確認
- CV値が高いカテゴリは単価交渉の余地あり
- 相場から外れた契約を特定

---

<br>

## 7. unit_price_details.csv

### 目的
**カテゴリ別・ベンダー別の契約単価詳細リスト**

### 集計ロジック

#### データソース
- `unit_price_analysis.csv`と同じ処理で生成されたデータ

#### 出力内容
```python
unit_price_details = contracts_with_price[[
    'contract_id',
    'vendor_id',
    'vendor_name',
    'primary_category',
    'contract_type',
    'monthly_amount'
]].copy()

# カテゴリ別、単価降順でソート
unit_price_details.sort_values(['primary_category', 'monthly_amount'], 
                               ascending=[True, False])
```

### 出力列

| 列名 | 説明 |
|------|------|
| contract_id | 契約ID |
| vendor_id | ベンダーID |
| vendor_name | ベンダー名 |
| primary_category | サービスカテゴリ |
| contract_type | 契約形態 |
| monthly_amount | 月額単価 |

### 用途
- カテゴリ内で最も高い/安い契約を特定
- 同一カテゴリ内のベンダー間比較
- 単価交渉の材料

---

<br>

## 8. auto_renewal_analysis.csv

### 目的
**自動更新契約の割合と影響度を分析**

### 集計ロジック

#### データソース
- **contracts.csv**: 契約データ

#### フィルタリング条件
```python
contract_status == '有効'  # 有効な契約のみを対象
```

#### 集計処理（auto_renewal_flagでグループ化）
```python
auto_renewal_analysis = active_contracts.groupby('auto_renewal_flag').agg({
    'contract_id': 'count',      # 契約数
    'annual_amount': 'sum',      # 年間金額の合計
    'renewal_count': 'mean'      # 更新回数の平均
})
```

#### 追加計算
1. **契約件数の構成比**
   ```python
   contract_ratio = (contract_count / 総契約数) × 100
   ```

2. **支出額の構成比**
   ```python
   amount_ratio = (annual_amount / 総支出額) × 100
   ```

### 出力列

| 列名 | 説明 | 計算方法 |
|------|------|---------|
| auto_renewal_flag | 自動更新フラグ | True/False |
| contract_count | 契約件数 | contract_idのカウント |
| annual_amount | 年間支出額 | annual_amountの合計 |
| avg_renewal_count | 平均更新回数 | renewal_countの平均 |
| contract_ratio | 契約件数構成比(%) | (件数/総件数)×100 |
| amount_ratio | 支出額構成比(%) | (金額/総金額)×100 |

### 用途
- 自動更新契約の割合を把握
- 自動更新による支出固定化のリスク評価
- 契約見直しの優先順位付け
- 平均更新回数から長期契約の傾向を分析

---

<br>

## 技術的なポイント

### 1. グループ化集計
```python
df.groupby('カラム').agg({
    '集計対象カラム1': '集計関数1',
    '集計対象カラム2': '集計関数2'
})
```
- `sum`: 合計
- `count`: 件数
- `mean`: 平均
- `median`: 中央値
- `min`, `max`: 最小値、最大値
- `std`: 標準偏差

### 2. データ結合
```python
df1.merge(df2, on='共通カラム', how='left')
```
- テーブル間の関連情報を結合

### 3. 条件フィルタリング
```python
df[df['カラム'] == '条件']
```
- 特定の条件に合致するレコードのみ抽出

### 4. ソートとランク付け
```python
df.sort_values('カラム', ascending=False)
df['rank'] = range(1, len(df) + 1)
```

